<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="./localize-behavior.html">
<link rel="import" href="./assessment-result-behavior.html">
<link rel="import" href="../d2l-colors/d2l-colors.html">
<link rel="import" href="../d2l-typography/d2l-typography-shared-styles.html">
<link rel="import" href="../s-html/s-html.html">
<link rel="import" href="../d2l-text-input/d2l-text-input.html">
<link rel="import" href="./siren-entity.html">


<dom-module id="d2l-rubric-editable-score">
	<template strip-whitespace>
		<style>
			:host {
				display: block;
			}
			/* TODO: Find a way to remove step arrows */
			d2l-text-input {
				max-width: 100px;
			}
			.score-out-of.assessed {
				color: var(--d2l-color-celestine);
			}
			.right {
				display: inline;
				padding: 0 5px;
			}
		</style>
		<siren-entity href="[[assessmentHref]]" token="[[token]]" entity="{{assessmentEntity}}"></siren-entity>
		<siren-entity href="[[criterionHref]]" token="[[token]]" entity="{{entity}}"></siren-entity>
		<div hidden="[[!editingScore]]">
			<d2l-text-input
				id="text-area"
				value="[[getScore(entity, assessmentResult, totalScore)]]"
				type="number"
			>
			</d2l-text-input>
			<div class="right">[[_localizeOutOf(entity)]]</div>
		</div>
		<div hidden="[[editingScore]]" class$="[[_getOutOfClassName(entity, assessmentResult)]]">
			[[_localizeOutOf(entity, assessmentResult, totalScore)]]
		</div>
	</template>

	<script>
		Polymer({
			is: 'd2l-rubric-editable-score',

			properties: {
				criterionHref: String,

				/* Entity could be a criterionEntity or a rubricEntity */
				entity: Object,

				assessmentHref: {
					type: String,
					value: null
				},
				token: String,
				_boundBlurHandler: {
					type: Function,
					value: function() {
						return this._blurHandler.bind(this);
					}
				},
				editingScore: {
					type: Boolean,
					value: false,
					notify: true
				},
				scoreOverridden: {
					type: Boolean,
					value: false
				},
				totalScore: {
					type: String,
					value: null
				}
			},

			behaviors: [
				D2L.PolymerBehaviors.Rubric.LocalizeBehavior,
				D2L.PolymerBehaviors.Rubric.AssessmentResultBehavior
			],

			observers: [
				'_onAssessmentResultChanged(criterionHref, assessmentResult)'
			],

			_onAssessmentResultChanged: function(criterionHref, assessmentResult) {
				if (!criterionHref || !assessmentResult) {
					return;
				}

				this.scoreOverridden = this.isScoreOverridden(criterionHref);
			},

			attached: function() {
				var elem = Polymer.dom(this.root).querySelector('d2l-text-input');
				if (!elem) {
					return;
				}
				elem.addEventListener('blur', this._boundBlurHandler);
			},

			detached: function() {
				var elem = Polymer.dom(this.root).querySelector('d2l-text-input');
				if (!elem) return;
				elem.removeEventListener('blur', this._boundBlurHandler);
			},

			focus: function() {
				var elem = Polymer.dom(this.root).querySelector('d2l-text-input');
				elem.focus();
			},

			_blurHandler: function(event) {
				var score = event.target.value;
				this.saveScore(score);
			},

			saveScore: function(score) {
				this.editingScore = false;
				if (this.criterionHref) {
					this.saveCriterionPoints(this.criterionHref, score);
				} else {
					this.saveTotalPoints(score);
				}
			},

			getScore: function(entity, assessmentResult, totalScore) {
				if (!entity || !assessmentResult) {
					return;
				}
				if (totalScore) {
					return totalScore;
				}
				return this.getAssessedScore(entity, assessmentResult);
			},

			_localizeOutOf: function(entity, assessmentResult, totalScore) {
				if (!entity || !entity.properties || !entity.properties.outOf) {
					return null;
				}

				var score = null;
				if (totalScore) {
					score = totalScore;
				} else if (assessmentResult) {
					score = this.getAssessedScore(entity, assessmentResult);
				}
				if (score || score === 0) {
					return this.localize('scoreOutOf', 'score', score.toString(), 'outOf', entity.properties.outOf.toString());
				}
				return this.localize('outOf', 'outOf', entity.properties.outOf.toString());
			},

			_getOutOfClassName: function(entity, assessmentResult) {
				var className = 'score-out-of';
				if (assessmentResult && this.scoreOverridden) {
					className += ' assessed';
				}
				return className;
			}
		});
	</script>
</dom-module>
