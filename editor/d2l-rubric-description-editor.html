<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../d2l-hm-constants-behavior/d2l-hm-constants-behavior.html">
<link rel="import" href="../../d2l-tooltip/d2l-tooltip.html">
<link rel="import" href="../../d2l-inputs/d2l-input-text.html">
<link rel="import" href="../d2l-rubric-entity-behavior.html">
<link rel="import" href="../../d2l-polymer-siren-behaviors/store/siren-action-behavior.html">
<link rel="import" href="./../localize-behavior.html">
<link rel="import" href="./d2l-rubric-text-editor.html">

<dom-module id="d2l-rubric-description-editor">
	<template strip-whitespace>
		<style>
			:host {
				display: flex;
				flex-direction: column;
				flex-grow: 1;
				min-height: 4rem;
			}

			* {
				box-sizing: border-box;
			}

			d2l-rubric-text-editor {
				flex-grow: 1;
				min-height: 4rem;
			}

			d2l-input-text {
				width: auto;
			}

			.points {
				display: flex;
				align-items: center;
				padding: 0.5rem;
			}

			.points div {
				margin-left: 0.5rem;
				@apply --d2l-body-compact-text;
			}

			:host-context([dir='rtl']) .points div {
				margin-right: 0.5rem;
				margin-left: 0;
			}

			#cell-points {
				min-width: calc(2.25rem + 1em);
			}

			[hidden] {
				display: none !important;
			}
		</style>

		<div class="points" hidden="[[!_showPoints]]">
			<d2l-input-text
				id="cell-points"
				value="[[entity.properties.points]]"
				on-change="_savePoints"
				aria-invalid="[[_isAriaInvalid(_pointsInvalid)]]"
				aria-label="[[localize('cellPoints')]]"
				disabled="[[!_canEditPoints]]"
				size="1"
				prevent-submit>
			</d2l-input-text>
			<div>[[localize('pointsAbbreviation')]]</div>
		</div>
		<d2l-rubric-text-editor
			id="description"
			token="[[token]]"
			key="[[_key]]"
			aria-invalid="[[_isAriaInvalid(_descriptionInvalid)]]"
			aria-label="[[_getAriaLabel(ariaLabelLangterm, criterionName, entity.properties)]]"
			disabled="[[!_canEditDescription]]"
			value=[[_getDescription(entity)]]
			on-change="_saveDescription"
			rich-text-enabled="[[richTextEnabled]]"
		>
		</d2l-rubric-text-editor>
		<template is="dom-if" if="[[_descriptionInvalid]]">
			<d2l-tooltip for="description" position="bottom">[[_descriptionInvalidError]]</d2l-tooltip>
		</template>
		<template is="dom-if" if="[[_pointsInvalid]]">
			<d2l-tooltip for="cell-points" position="bottom">[[_pointsInvalidError]]</d2l-tooltip>
		</template>
	</template>

	<script>
		Polymer({
			is: 'd2l-rubric-description-editor',

			properties: {
				/**
				 * textarea aria-label langterm
				 */
				ariaLabelLangterm: {
					type: String,
					value: ''
				},
				criterionName: {
					type: String,
					value: ''
				},
				keyLinkRels: {
					type: Array,
					value: function() { return ['self']; }
				},
				_key: {
					type: String,
					computed: '_constructKey(keyLinkRels, entity)',
				},
				_canEditDescription: {
					type: Boolean,
					computed: '_computeCanEditDescription(entity)',
				},
				_canEditPoints: {
					type: Boolean,
					computed: '_computeCanEditPoints(entity)',
				},
				_descriptionInvalid: {
					type: Boolean
				},
				_descriptionInvalidError: {
					type: String
				},
				_pointsRequired: {
					type: Boolean,
					computed: '_arePointsRequired(entity)',
				},
				_pointsInvalid: {
					type: Boolean
				},
				_pointsInvalidError: {
					type: String
				},
				_showPoints: {
					type: Boolean,
					computed: '_computeShowPoints(entity)'
				},
				richTextEnabled: Boolean
			},
			observers: [
				'_onEntityChanged(entity)'
			],
			behaviors: [
				D2L.PolymerBehaviors.Rubric.EntityBehavior,
				D2L.PolymerBehaviors.Siren.SirenActionBehavior,
				window.D2L.Hypermedia.HMConstantsBehavior,
				D2L.PolymerBehaviors.Rubric.LocalizeBehavior
			],
			_onEntityChanged: function() {
				this._descriptionInvalid = false;
				this._pointsInvalid = false;
			},
			_getAriaLabel: function(langTerm, criterionName, properties) {
				var levelName = properties && properties.levelName || properties && properties.name;
				return this.localize(langTerm, 'criterionName', criterionName, 'levelName', levelName);
			},

			_getDescriptionAction: function(entity) {
				// Default to 'update' if 'update-description' is not present. Mostly for BG purposes
				// while the overall levels API is updated to use 'update-description'. Can be removed
				// later.
				var action;
				var description = entity && entity.getSubEntityByClass(this.HypermediaClasses.rubrics.description);
				if (description) {
					action = description.getActionByName('update-description');
					if (!action) {
						action = description.getActionByName('update');
					}
				}
				return action;
			},

			_getDescription: function(entity) {
				var action = this._getDescriptionAction(entity);
				if (action) {
					return action.getFieldByName('description').value;
				}
				return '';
			},

			_saveDescription: function(e) {
				var action = this._getDescriptionAction(this.entity);
				if (action) {
					this._toggleBubble('_descriptionInvalid', false);
					var fields = [{'name':'description', 'value':e.detail.value}];
					this.performSirenAction(action, fields).then(function() {
						this.fire('d2l-rubric-description-saved');
					}.bind(this)).catch(function(err) {
						this._toggleBubble('_descriptionInvalid', true, this._getErrMsg(err, 'descriptionSaveFailed'));
					}.bind(this));
				}
			},
			_getErrMsg: function(e, altMsg) {
				if (!e.hasOwnProperty('stack')) {
					var errObj = e.string ? e.string : e.json;
					if (errObj.hasOwnProperty('properties')) {
						return errObj.properties.detail;
					}
				}
				return this.localize(altMsg);
			},
			_arePointsRequired: function(entity) {
				var action = entity && entity.getActionByName('update-points');
				if (!action) {
					return false;
				}
				var field = action.getFieldByName('points');
				if (!field) {
					return false;
				}
				return field.hasClass('required');
			},
			_computeCanEditDescription: function(entity) {
				var description = entity && entity.getSubEntityByClass(this.HypermediaClasses.rubrics.description);
				return description && (description.hasActionByName('update-description') || description.hasActionByName('update'));
			},

			_computeCanEditPoints: function(entity) {
				return entity && entity.hasActionByName('update-points');
			},

			_computeShowPoints: function(entity) {
				return entity && entity.hasClass(this.HypermediaClasses.rubrics.overridden);
			},

			_savePoints: function(e) {
				var action = this.entity.getActionByName('update-points');
				if (action) {
					if (this._pointsRequired && !e.target.value.trim()) {
						this._toggleBubble('_pointsInvalid', true, this.localize('pointsAreRequired'));
					} else {
						this._toggleBubble('_pointsInvalid', false);
						var fields = [{ 'name': 'points', 'value': e.target.value }];
						this.performSirenAction(action, fields).then(function() {
							this.fire('d2l-rubric-criterion-cell-points-saved');
						}.bind(this)).catch(function(err) {
							this._toggleBubble('_pointsInvalid', true, this._getErrMsg(err, 'pointsSaveFailed'));
						}.bind(this));
					}
				}
			},

			_toggleBubble: function(invalidId, show, error) {
				if (show) {
					this.set(invalidId, true);
					this.set(invalidId + 'Error', error);
				} else {
					this.set(invalidId, false);
				}
			},

			_isAriaInvalid: function(valueInvalid) {
				return new Boolean(valueInvalid).toString();
			},

			_constructKey: function(keyLinkRels, entity) {
				var constructed = '';
				if (entity && entity.hasLinkByRel) {
					keyLinkRels.forEach(function(rel) {
						if (entity.hasLinkByRel(rel)) {
							constructed += entity.getLinkByRel(rel).href;
							constructed += '|';
						}
					});
				}
				return constructed;
			}
		});
	</script>
</dom-module>
